

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>chem_topo.adsorption_sites &mdash; chem_topo 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            chem_topo
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">chem_topo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">chem_topo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">chem_topo.adsorption_sites</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for chem_topo.adsorption_sites</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">ase</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atoms</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ase.neighborlist</span><span class="w"> </span><span class="kn">import</span> <span class="n">natural_cutoffs</span><span class="p">,</span> <span class="n">NeighborList</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gudhi</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ase.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">covalent_radii</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_centroid</span> <span class="p">,</span> <span class="n">get_cutoffs</span> <span class="p">,</span><span class="n">metal_elements</span><span class="p">,</span><span class="n">plane_normal</span>
<div class="viewcode-block" id="ClusterAdsorptionSitesFinder">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ClusterAdsorptionSitesFinder</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------        </span>
<span class="sd">        - atoms : ase.Atoms object</span>
<span class="sd">                The nanoparticle to use as a template to generate surface sites. </span>
<span class="sd">                Accept any ase.Atoms object. </span>

<span class="sd">        - adsorbate_elements : list of strs</span>
<span class="sd">                If the sites are generated without considering adsorbates, </span>
<span class="sd">                the symbols of the adsorbates are entered as a list, resulting in a clean slab</span>

<span class="sd">        - bond_len : float , default None</span>
<span class="sd">                The sum of the atomic radii between a reasonable adsorption </span>
<span class="sd">                substrate and the adsorbate.If not setting, the threshold for </span>
<span class="sd">                the atomic hard sphere model is automatically calculated using </span>
<span class="sd">                the covalent radius of ase</span>

<span class="sd">        - mul : float , default 0.8</span>
<span class="sd">                A scaling factor for the atomic bond lengths used to modulate</span>
<span class="sd">                the number of sites generated, resulting in a larger number of potential sites </span>

<span class="sd">        - tol : float , default 0.6</span>
<span class="sd">                The minimum distance in Angstrom between two site for removal</span>
<span class="sd">                of partially overlapping site</span>

<span class="sd">        - radius : float , default 5.0</span>
<span class="sd">                The maximum distance between two points </span>
<span class="sd">                when performing persistent homology calculations  </span>

<span class="sd">        - k : float , default 1.1</span>
<span class="sd">                Expand the key length, so as to calculate the length of the expansion</span>
<span class="sd">                in the direction of the normal vector, k value is too small will lead </span>
<span class="sd">                to the calculation of the length of the expansion of the error, </span>
<span class="sd">                you can according to the needs of appropriate increase</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="p">,</span>
                        <span class="n">adsorbate_elements</span><span class="o">=</span><span class="p">[],</span>
                        <span class="n">bond_len</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">mul</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                        <span class="n">k</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
                        <span class="n">radius</span><span class="o">=</span><span class="mf">5.</span><span class="p">):</span>
                <span class="k">assert</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="s1">&#39;the cell must be non-periodic&#39;</span> <span class="c1"># Ensure the cell is non-periodic (PBC must be False)</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Make a copy of the atoms object to avoid modifying the original</span>
                <span class="c1"># Loop through each dimension to ensure the cell dimensions are valid</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="c1"># If the dimension length is zero, set it to the range of atomic positions plus a buffer</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># Set dimension length to the range plus 10</span>
                                <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">])</span> <span class="o">+</span> <span class="mf">10.</span>
                <span class="c1"># Identify the indices of metal atoms (those whose symbols are not in adsorbate_elements)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adsorbate_elements</span><span class="p">]</span>

                <span class="c1"># Create a new Atoms object with only the metal atoms</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span><span class="p">],</span> 
                        <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span><span class="p">],</span> 
                        <span class="n">cell</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span> 
                <span class="c1"># Initialize various attributes of the class with relevant data from the atoms object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="o">=</span> <span class="n">bond_len</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numbers</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">numbers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">mul</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">=</span> <span class="n">radius</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span><span class="p">)))</span>
                <span class="c1">#get surface atoms based on coordination</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_atoms</span><span class="p">()</span>
                <span class="c1"># Initialize empty lists for surface sites and inside sites</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># Set radii for surface and inside adsorption sites(drfault H)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="o">=</span> <span class="n">covalent_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_add_radii</span> <span class="o">=</span> <span class="n">covalent_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Initialize lists for surface indices and sites</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sur_index</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.get_surface_atoms">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.get_surface_atoms">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_surface_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Identify surface atoms in a structure based on the sum of neighbor direction vectors.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - cutoff : float</span>
<span class="sd">                        Cutoff radius for neighbor search (in Ångströms)</span>
<span class="sd">                </span>
<span class="sd">                - tolerance : float </span>
<span class="sd">                        If the magnitude of the summed normal vectors is less than this value, </span>
<span class="sd">                        the atom is considered a non-surface atom</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - surf_ids : list</span>
<span class="sd">                        List of indices of surface atoms.</span>

<span class="sd">                - surface_atoms : ase.Atoms object</span>
<span class="sd">                        Atoms object containing only the detected surface atoms.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
                <span class="n">num_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                
                <span class="n">neighbor_list</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">([</span><span class="n">cutoff</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_atoms</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">neighbor_list</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                <span class="n">surface_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">max_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbor_list</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">)])</span>
                <span class="n">threshold_neighbors</span> <span class="o">=</span> <span class="n">max_neighbors</span> <span class="o">-</span> <span class="mi">2</span>
                
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">):</span>
                        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">surface_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                <span class="k">continue</span>

                        <span class="n">pos_i</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">summed_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
                                <span class="n">pos_j</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                        <span class="n">normal</span> <span class="o">=</span> <span class="n">pos_j</span> <span class="o">-</span> <span class="n">pos_i</span>
                        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                                <span class="n">summed_normal</span> <span class="o">+=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">norm</span>  

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold_neighbors</span> <span class="ow">and</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">summed_normal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="n">surface_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">surf_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">surface_indices</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">surface_indices</span> <span class="p">,</span> <span class="n">surf_atoms</span></div>



<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.extend_point_away_from_center">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.extend_point_away_from_center">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">extend_point_away_from_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Offset a surface site along the normal vector.</span>

<span class="sd">                This function generates a normal vector using the center of mass of the </span>
<span class="sd">                initial atom cluster and offsets the point outward by a specified distance.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - center : ndarray</span>
<span class="sd">                        The center point of the cluster.</span>

<span class="sd">                - point : ndarray</span>
<span class="sd">                        The site to be offset outward.</span>

<span class="sd">                - distance : float</span>
<span class="sd">                        The distance to offset in the direction of the normal vector.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - new_point : ndarray</span>
<span class="sd">                        The new position of the point after being offset.</span>

<span class="sd">                - unit_vector : ndarray</span>
<span class="sd">                        The unit vector representing the direction of the offset.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Calculate the vector from the center to the point</span>
                <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

                <span class="c1"># Calculate the length of the vector</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>

                <span class="c1"># Ensure the point and center are not the same</span>
                <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The point and center cannot be the same.&quot;</span><span class="p">)</span>

                <span class="c1"># Normalize the vector to get the unit vector</span>
                <span class="n">unit_vector</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">length</span>

                <span class="c1"># Offset the point along the unit vector by the specified distance</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">*</span> <span class="n">unit_vector</span>

                <span class="k">return</span> <span class="n">new_point</span><span class="p">,</span> <span class="n">unit_vector</span></div>


<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.get_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.get_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absorbent</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Retrieve all adsorption sites (surface and inside).</span>

<span class="sd">                This method combines surface and inside sites into a single list. If these </span>
<span class="sd">                sites have not been previously calculated, it computes them first.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list, optional</span>
<span class="sd">                        A list of atoms or elements to be considered during site calculations.</span>
<span class="sd">                        Defaults to an empty list.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - sites : list</span>
<span class="sd">                        A list of all adsorption sites, including both surface and inside sites.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Return precomputed sites if available</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span>

                <span class="c1"># Calculate surface sites if not already computed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_sites</span><span class="p">(</span><span class="n">absorbent</span><span class="o">=</span><span class="n">absorbent</span><span class="p">)</span>

                <span class="c1"># Calculate inside sites if not already computed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_inside_sites</span><span class="p">(</span><span class="n">absorbent</span><span class="o">=</span><span class="n">absorbent</span><span class="p">)</span>

                <span class="c1"># Combine surface and inside sites into a single list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span></div>



<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.surf_topo">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.surf_topo">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">surf_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                The function to topologize surface atoms and obtain sites.</span>
<span class="sd">                It uses Alpha Complex to calculate surface topology and generates adsorption sites.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                Updates self.surf_site_list with the surface sites generated.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Get the center of mass of the atoms and positions of surface atoms</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
                <span class="n">surf_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_atoms</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
                <span class="n">surface_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_atoms</span>

                <span class="c1"># Initialize an Alpha Complex with surface atom positions</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">AlphaComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">surf_pos</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Alpha Complex filtration radius</span>

                <span class="c1"># Get the simplicial complex (up to 4-simplex)</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

                <span class="c1"># Initialize site types and groups for tracking</span>
                <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">site_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bridge&#39;</span><span class="p">,</span> <span class="s1">&#39;hollow&#39;</span><span class="p">,</span> <span class="s2">&quot;4fold&quot;</span><span class="p">]</span>
                <span class="n">fold4_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">del_bri_couple</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Sort combinations by simplex size (from higher dimensions to lower)</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Iterate through the simplices in the Alpha Complex</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">surf_pos</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Get positions of the atoms in the simplex</span>
                        <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_atoms</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Covalent radii of atoms</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Single atom (top site)</span>
                                <span class="n">temp_com</span> <span class="o">=</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Two atoms (bridge site)</span>
                                <span class="n">temp_com</span> <span class="o">=</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="c1"># Remove the bridge of the two hypotenuses of the 4-fold site.</span>
                                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">in</span> <span class="n">del_bri_couple</span><span class="p">:</span>
                                        <span class="k">continue</span>
                                <span class="n">t</span> <span class="o">=</span> <span class="n">cov_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Weighted position between the two atoms</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Higher-order sites (hollow, 4-fold)</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>

                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">cov_radii</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># Calculate the centroid</span>
                                <span class="n">temp_com</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[]</span>

                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surf_pos</span><span class="p">):</span>  <span class="c1"># Adjust site based on nearby atoms</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">site</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bond_len</span><span class="p">:</span>
                                                <span class="n">temp_com</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                        <span class="n">cov_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>

                                <span class="c1"># Handle 4-fold and hollow cases</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                        <span class="n">index_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">index_tuple</span> <span class="ow">in</span> <span class="n">fold4_group</span><span class="p">:</span>
                                                <span class="k">continue</span>
                                        <span class="k">else</span><span class="p">:</span>
                                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">surf_pos</span><span class="p">[</span><span class="n">temp_com</span><span class="p">],</span> <span class="n">cov_radii</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                                <span class="n">fold4_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_tuple</span><span class="p">)</span>

                                        <span class="c1"># Identify and exclude redundant bridge combinations</span>
                                        <span class="n">max_d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">surf_pos</span><span class="p">[</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">surf_pos</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">:</span>
                                                        <span class="n">max_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">surf_pos</span><span class="p">[</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">surf_pos</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                                                        <span class="n">temp_i</span> <span class="o">=</span> <span class="n">ind</span>
                                        <span class="n">del_bri_couple</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_i</span><span class="p">))</span>

                                        <span class="n">remain</span> <span class="o">=</span> <span class="p">[]</span>
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">:</span>
                                                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">temp_i</span><span class="p">:</span>
                                                        <span class="n">remain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                        <span class="n">del_bri_couple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remain</span><span class="p">))</span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                        <span class="n">temp_com</span> <span class="o">=</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># Offset the site away from the center of mass</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                        <span class="k">else</span><span class="p">:</span>
                                <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>

                        <span class="k">try</span><span class="p">:</span>
                                <span class="n">height</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="n">height</span> <span class="o">=</span> <span class="mf">0.1</span>

                        <span class="n">site</span><span class="p">,</span> <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_point_away_from_center</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

                        <span class="c1"># Check if the site is too close to existing atoms</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">&lt;</span> <span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                        <span class="k">break</span>

                        <span class="c1"># If valid, add the site to the list</span>
                        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                                <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                        <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="n">site_type</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;surface&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="n">normal</span><span class="p">,</span>
                                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                                        <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">]</span>
                                <span class="p">})</span>

                <span class="c1"># Handle site proximity for final site list</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">=</span> <span class="n">sites</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span></div>



<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.get_surface_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.get_surface_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_surface_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absorbent</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Generate and return surface adsorption sites based on surface topology.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list of str, optional</span>
<span class="sd">                        A list of chemical symbols for adsorbent elements (e.g., [&#39;H&#39;, &#39;O&#39;]).</span>
<span class="sd">                        Used to adjust radii for adsorbent-related calculations.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - surf_site_list : list of dict</span>
<span class="sd">                        A list of dictionaries containing information about surface adsorption sites.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Adjust the additional radii based on the provided absorbent elements</span>
                <span class="k">if</span> <span class="n">absorbent</span><span class="p">:</span>
                        <span class="c1"># Calculate the minimum covalent radius for the given absorbent elements</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">absorbent</span><span class="p">])</span>

                <span class="c1"># Generate surface sites based on surface topology</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_topo</span><span class="p">()</span>

                <span class="c1"># Return the list of surface sites</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span></div>



<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.inside_topo">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.inside_topo">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">inside_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Identify embedding sites within non-periodic structures (e.g., nanoclusters).</span>

<span class="sd">                Uses Alpha Complex and Rips Complex to find topological embedding sites.</span>

<span class="sd">                - Updates `self.inside_site_list` with identified embedding sites.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>  <span class="c1"># Atomic positions of the structure</span>
                
                <span class="c1"># Computing sites in 4 dimensions using Alpha Complex</span>
                <span class="n">ac</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">AlphaComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>    
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="c1"># Process lower-dimensional combinations (up to 4)</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Sites formed by at least 2 atoms</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Extract positions</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        
                                <span class="c1"># Compute site position</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                        <span class="n">t</span> <span class="o">=</span> <span class="n">cov_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span>
                                        <span class="n">site</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">cov_radii</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

                                <span class="c1"># Define bond length</span>
                                <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                
                                <span class="c1"># Check site validity (not too close to existing atoms)</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.001</span> <span class="o">&lt;</span> <span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span>
                                
                                <span class="c1"># Save valid site</span>
                                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                        <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                                        <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                        <span class="p">})</span>

                <span class="c1"># Computing higher-dimensional sites using Rips Complex</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">RipsComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">max_edge_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
                
                <span class="c1"># Process higher-dimensional combinations (&gt; 4)</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">cov_radii</span><span class="p">,</span> <span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                        
                        <span class="c1"># Define bond length</span>
                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                        
                        <span class="c1"># Check site validity</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.001</span> <span class="o">&lt;</span> <span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                        <span class="k">break</span>
                        
                        <span class="c1"># Save valid site</span>
                        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                                <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                                <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="p">})</span>

                <span class="c1"># Validate and add sites to `self.inside_site_list`</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span> <span class="o">=</span> <span class="n">sites</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span></div>



        
<div class="viewcode-block" id="ClusterAdsorptionSitesFinder.get_inside_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.ClusterAdsorptionSitesFinder.get_inside_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_inside_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absorbent</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Identify and return the list of inside sites for the structure.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list, optional</span>
<span class="sd">                        A list of element symbols representing adsorbent elements. If provided, </span>
<span class="sd">                        the `inside_add_radii` parameter is adjusted based on their covalent radii.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - inside_site_list : list</span>
<span class="sd">                        A list of dictionaries, each describing an inside site.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Adjust the additional radius for inside sites if adsorbent elements are provided</span>
                <span class="k">if</span> <span class="n">absorbent</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">inside_add_radii</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span>
                        <span class="n">covalent_radii</span><span class="p">[</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> 
                        <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">absorbent</span>
                        <span class="p">])</span>
                
                <span class="c1"># Compute the inside sites</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_topo</span><span class="p">()</span>
                
                <span class="c1"># Return the list of inside sites</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span></div>
</div>





<div class="viewcode-block" id="SlabAdsorptionsSitesFinder">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SlabAdsorptionsSitesFinder</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        - atoms : ase.Atoms object</span>
<span class="sd">                The nanoparticle to use as a template to generate surface sites. </span>
<span class="sd">                Accept any ase.Atoms object. </span>

<span class="sd">        - adsorbate_elements : list of str</span>
<span class="sd">                If the sites are generated without considering adsorbates, </span>
<span class="sd">                the symbols of the adsorbates are entered as a list, resulting in a clean slab.</span>

<span class="sd">        - bond_len : float or None , default None</span>
<span class="sd">                The sum of the atomic radii between a reasonable adsorption </span>
<span class="sd">                substrate and the adsorbate.If not setting, the threshold for </span>
<span class="sd">                the atomic hard sphere model is automatically calculated using </span>
<span class="sd">                the covalent radius of ase.</span>

<span class="sd">        - mul : float , default 0.8</span>
<span class="sd">                A scaling factor for the atomic bond lengths used to modulate</span>
<span class="sd">                the number of sites generated, resulting in a larger number of potential sites. </span>

<span class="sd">        - tol : float , default 0.6</span>
<span class="sd">                The minimum distance in Angstrom between two site for removal</span>
<span class="sd">                of partially overlapping site.</span>

<span class="sd">        - radius : float , default 5.0</span>
<span class="sd">                The maximum distance between two points </span>
<span class="sd">                when performing persistent homology calculations. </span>

<span class="sd">        - k : float , default 1.1</span>
<span class="sd">                Expand the key length, so as to calculate the length of the expansion</span>
<span class="sd">                in the direction of the normal vector, k value is too small will lead </span>
<span class="sd">                to the calculation of the length of the expansion of the error, </span>
<span class="sd">                you can according to the needs of appropriate increase</span>

<span class="sd">        - both_surface : bool , default False</span>
<span class="sd">                Input whether sites generation is performed on both the upper and </span>
<span class="sd">                lower surfaces; when the input is False, only the upper surface is output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="p">,</span>
                        <span class="n">adsorbate_elements</span><span class="o">=</span><span class="p">[],</span>
                        <span class="n">mul</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                        <span class="n">bond_len</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">k</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
                        <span class="n">radius</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span>
                        <span class="n">both_surface</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="p">):</span>
                <span class="c1"># Create a copy of the atoms object to avoid modifying the original</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Get the indices of all metal atoms by excluding atoms from adsorbate_elements</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adsorbate_elements</span><span class="p">]</span>
                <span class="c1"># Create a new Atoms object with only the metal atoms</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span><span class="p">],</span> 
                        <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metal_ids</span><span class="p">],</span> 
                        <span class="n">cell</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span> 
                <span class="c1"># Initialize various attributes of the class with relevant data from the atoms object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numbers</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">numbers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="o">=</span> <span class="n">bond_len</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">=</span> <span class="n">mul</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">=</span> <span class="n">radius</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">symbols</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">both_surface</span> <span class="o">=</span> <span class="n">both_surface</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metal_elements</span> <span class="o">=</span> <span class="n">metal_elements</span>

                <span class="c1"># Set the default covalent radius for surface site calculations(default H)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="o">=</span> <span class="n">covalent_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_add_radii</span> <span class="o">=</span> <span class="n">covalent_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 

                <span class="c1"># Initialize an empty list to store site information</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_index</span> <span class="o">=</span> <span class="p">[]</span>
                
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.get_surface_atoms">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.get_surface_atoms">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_surface_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span><span class="n">both_surface</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;The function to access to surface atoms by coordination number</span>

<span class="sd">                Parameters:    </span>
<span class="sd">                -----------</span>
<span class="sd">                - cutoff : float</span>
<span class="sd">                        Cutoff radius for neighbor search (in Ångströms)</span>
<span class="sd">                </span>
<span class="sd">                - tolerance : float </span>
<span class="sd">                        If the magnitude of the summed normal vectors is less than this value, </span>
<span class="sd">                        the atom is considered a non-surface atom</span>

<span class="sd">                - both_surface : boolen , default False</span>
<span class="sd">                        Whether to return the atoms of the lower surface, </span>
<span class="sd">                        if True, the atoms of the upper and lower surfaces will be returned.</span>
<span class="sd">                </span>
<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - surf_ids : list</span>
<span class="sd">                        List of indices of surface atoms.</span>

<span class="sd">                - surface_atoms : ase.Atoms object</span>
<span class="sd">                        Atoms object containing only the detected surface atoms.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Get the z-coordinates of all atoms</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
                <span class="n">z_coords</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

                <span class="n">num_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                <span class="c1"># If all z-coordinates are identical, return all atoms as surface atoms</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">z_coords</span> <span class="o">==</span> <span class="n">z_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">:</span>
                        <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)),</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
                
                <span class="n">neighbor_list</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">([</span><span class="n">cutoff</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_atoms</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">neighbor_list</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
                <span class="n">surface_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># Initialize variables to store surface atoms and their indices</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">):</span>
                        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">neighbor_list</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">surface_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                <span class="k">continue</span>

                        <span class="n">pos_i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">summed_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
                                <span class="n">pos_j</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                                <span class="n">normal</span> <span class="o">=</span> <span class="n">pos_j</span> <span class="o">-</span> <span class="n">pos_i</span>
                                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                                        <span class="n">summed_normal</span> <span class="o">+=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">norm</span>  

                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">summed_normal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="n">surface_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Add the atom to the surface Atoms object</span>
                
                <span class="n">surface_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">surface_indices</span><span class="p">]</span>
                <span class="c1"># Get the z-coordinates of surface atoms and calculate the median z-coordinate</span>
                <span class="n">z_positions</span> <span class="o">=</span> <span class="n">surface_atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">median_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">z_positions</span><span class="p">)</span> 
                <span class="c1"># If both_surface is True, return all surface atoms and their indices</span>
                <span class="k">if</span> <span class="n">both_surface</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">surface_indices</span> <span class="p">,</span> <span class="n">surface_atoms</span>
                
                <span class="c1"># Otherwise, return only the atoms on the upper surface</span>
                <span class="n">upper_index</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">upper_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">surface_indices</span><span class="p">,</span><span class="n">surface_atoms</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">median_z</span><span class="p">:</span> <span class="c1"># Check if the atom is on the upper surface</span>
                                <span class="n">upper_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Add the atom index to the upper surface list</span>
                                <span class="n">upper_atoms</span> <span class="o">+=</span> <span class="n">atom</span>  <span class="c1"># Add the atom to the upper surface Atoms object</span>
                <span class="k">return</span> <span class="n">upper_index</span> <span class="p">,</span> <span class="n">upper_atoms</span>         </div>

        
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.expand_cell">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.expand_cell">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">expand_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Return Cartesian coordinates of atoms within a supercell,</span>
<span class="sd">                which contains repetitions of the unit cell and at least one neighboring atom.</span>
<span class="sd">                Borrowed from Catkit.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - cutoff : float, optional</span>
<span class="sd">                        A cutoff value to determine the maximum distance for expansion. If None, it is computed.</span>

<span class="sd">                - padding : list of int, optional, default [1,1,0]</span>
<span class="sd">                        Padding values for the expansion in each direction. These define the number of unit cell repetitions</span>
<span class="sd">                        along each of the three axes (x, y, z).</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">cell</span>  <span class="c1"># Get the cell matrix (unit cell) and positions of the atoms</span>
                <span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Define periodic boundary conditions (no periodicity in z-direction)</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span>

                <span class="c1"># If no padding or cutoff is provided, compute the cutoff based on the system geometry</span>
                <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Compute diagonal lengths of the unit cell</span>
                        <span class="n">diags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.point_in_range">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.point_in_range">[docs]</a>
                                        <span class="o">@</span> <span class="n">cell</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># If there is only one atom, set cutoff to half of the maximum diagonal length</span>
                        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">diags</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
                        <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Compute the distances between atoms and update the cutoff</span>
                                <span class="n">dpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                                <span class="n">Dr</span> <span class="o">=</span> <span class="n">dpos</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
                                <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dr</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Dr</span><span class="p">)</span> <span class="o">*</span> <span class="n">pbc</span><span class="p">)</span> <span class="o">@</span> <span class="n">cell</span>
                                <span class="n">D_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">D</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

                                <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">D_len</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">diags</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                <span class="c1"># Calculate the lattice lengths and volume of the unit cell</span>
                <span class="n">latt_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">cell</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">V</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>

                <span class="c1"># padding = pbc * np.array(np.ceil(cutoff * np.prod(latt_len) /</span>
                                                <span class="c1"># (V * latt_len)), dtype=int)</span>
                <span class="c1"># Create offset grid based on the provided padding in x, y, and z directions</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="o">-</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="o">-</span><span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># Generate translation vectors by multiplying offsets with the cell matrix</span>
                <span class="n">tvecs</span> <span class="o">=</span> <span class="n">offsets</span> <span class="o">@</span> <span class="n">cell</span>
                <span class="c1"># Calculate the coordinates of atoms in the expanded supercell</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">tvecs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Flatten the offsets and coordinates to return the expanded supercell structure</span>
                <span class="n">ncell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">offsets</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Total number of unit cell repetitions</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">offsets</span></div>

        
        <span class="k">def</span><span class="w"> </span><span class="nf">point_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Determine if a given site (position) is within the current lattice boundaries.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - pos : array</span>
<span class="sd">                        The Cartesian coordinates of the point to be checked.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - bool</span>
<span class="sd">                        True if the point is within the lattice boundaries, False otherwise.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Get the minimum and maximum z-coordinates of the atoms</span>
                <span class="n">z_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">z_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>

                <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="c1"># Get the cell dimensions (lattice vectors)</span>
                <span class="c1"># Check if the point lies within the boundaries along x, y, and z directions</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> 
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">0.1</span><span class="p">):</span>  <span class="c1"># Check x, y, and z against lattice boundaries</span>
                                <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Check if the z-coordinate is within the range of atomic position</span>
                <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">z_min</span><span class="o">-</span><span class="mf">0.1</span> <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">z_max</span><span class="o">+</span><span class="mf">0.1</span><span class="p">:</span> 
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span></div>


                        
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.inside_topo">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.inside_topo">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">inside_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot; This is a function used to find embedding sites for various</span>
<span class="sd">                periodic structures.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># If the structure is not periodic, use the current atomic positions</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For periodic structures, expand the cell to account for neighboring atoms</span>
                        <span class="n">index</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_cell</span><span class="p">()</span>
                <span class="c1"># Computing sites in 4 dimensions using alpha complexes</span>
                <span class="n">ac</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">AlphaComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Alpha complex with squared radii </span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># Alpha complex with squared radii</span>
                <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># List to store identified embedding sites</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="c1"># Number of atoms</span>
                <span class="n">kdtree</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># To store the KDTree for fast distance checking</span>
                <span class="c1"># Iterate through the simplices of the Alpha Complex</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                        <span class="c1"># Ensure the simplex is at least 2D and not on the surface</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="o">%</span> <span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_index</span><span class="p">:</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Extract positions of the simplex vertices</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Covalent radii of vertices</span>
                                <span class="c1"># Calculate the site position based on simplex vertices and radii</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># If the simplex is 2D (edge)</span>
                                        <span class="n">t</span> <span class="o">=</span> <span class="n">cov_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span>
                                        <span class="n">site</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span> <span class="c1"># For higher-dimensional simplices</span>
                                        <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">cov_radii</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="c1"># Skip the site if it&#39;s outside the current lattice boundaries</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_in_range</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Determine bond length for proximity checks</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>

                                <span class="c1"># Create a KDTree once, and use it to check proximity for all points</span>
                                <span class="k">if</span> <span class="n">kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

                                <span class="c1"># Check if any point is within bond_len range</span>
                                <span class="n">nearby_points</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">+</span> <span class="mf">0.02</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearby_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> <span class="c1"># If no nearby points, add the site</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                        <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                                        <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                        <span class="p">})</span>                       
                <span class="c1"># Compute loci larger than 4 dimensions using VR complex shapes</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">RipsComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">max_edge_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">)</span> <span class="c1"># Rips Complex with max edge length</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># Build a simplex tree up to 10 dimensions</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># Get simplices up to 10 dimensions</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Sort simplices by size</span>
                <span class="c1"># Process high-dimensional simplices</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># Only consider simplices with more than 4 vertices</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Extract positions of simplex vertices</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Covalent radii of vertices</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">cov_radii</span><span class="p">,</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Calculate site position</span>

                                <span class="c1"># Skip the site if it&#39;s outside the current lattice boundaries</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_in_range</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                                        <span class="k">continue</span>

                                <span class="c1"># Determine bond length for proximity checks</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                <span class="c1"># Check proximity using KDTree</span>
                                <span class="n">nearby_points</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">bond_len</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span> <span class="o">+</span> <span class="mf">0.02</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearby_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> <span class="c1"># If no nearby points, add the site</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                        <span class="s1">&#39;site&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;inside&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;normal&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                                        <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                        <span class="p">})</span>
                <span class="c1"># Filter and store sites based on tolerance criteria</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># If no tolerance filtering is required</span>
                        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                                <span class="n">flag</span>  <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                        <span class="k">break</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> 
                <span class="k">else</span><span class="p">:</span> <span class="c1"># Apply tolerance-based filtering</span>
                        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                                <span class="n">flag</span>  <span class="o">=</span> <span class="kc">True</span>
                                 <span class="c1"># Check against surface site list</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Check against existing inside site list</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> </div>

<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.expand_surface_cells">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.expand_surface_cells">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">expand_surface_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">original_atoms</span><span class="p">,</span><span class="n">cell</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Return Cartesian coordinates of surface atoms within a supercell.</span>
<span class="sd">                </span>
<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - original_atoms : ase.Atoms object</span>
<span class="sd">                        The surface atoms that need to be expanded.</span>
<span class="sd">                </span>
<span class="sd">                - cell : list of float</span>
<span class="sd">                        Lattice vectors of the atomic structure.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Extract lattice vectors in the x and y directions</span>
                <span class="n">la_x</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Lattice vector along x-direction</span>
                <span class="n">la_y</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Lattice vector along y-direction</span>

                <span class="c1"># Initialize a list to store new atom positions</span>
                <span class="n">new_atoms</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Define the expansion factor for the supercell</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Supercell will be (3x3) in x and y directions</span>

                <span class="c1"># Supercell will be (3x3) in x and y directions</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># Offset to center the supercell expansion</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="c1"># Convert to integer for iteration</span>

                <span class="c1"># Iterate through shifts in x and y directions</span>
                <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># Loop over x-axis offsets</span>
                        <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># Loop over y-axis offsets</span>
                                <span class="c1"># Iterate through all atoms in the original structure</span>
                                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">original_atoms</span><span class="p">:</span>
                                        <span class="c1"># Calculate the new position by adding lattice translations</span>
                                        <span class="n">new_position</span> <span class="o">=</span> <span class="n">atom</span> <span class="o">+</span> <span class="n">dx</span><span class="o">*</span><span class="n">la_x</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">la_y</span>
                                        <span class="c1"># Append the new position to the list</span>
                                        <span class="n">new_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_position</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span></div>


<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.calculate_normal_vector">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.calculate_normal_vector">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_normal_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">positions</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Calculate the normal vector of a surface given three points.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - positions : array-like, shape (3, 3)</span>
<span class="sd">                        The Cartesian coordinates of three points on the surface.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - normal : numpy array</span>
<span class="sd">                        A normalized normal vector pointing outward from the surface.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Compute two vectors lying on the surface</span>
                <span class="n">vec1</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Vector from point 0 to point 1</span>
                <span class="n">vec2</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Vector from point 0 to point 2</span>

                <span class="c1"># Calculate the cross product of the two vectors to get the normal vector</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
                <span class="c1"># Check if the normal vector has zero magnitude (degenerate triangle)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># If degenerate, return the default normal vector [0, 0, 1]</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
                <span class="c1"># Ensure the normal vector points upwards (positive z-component)</span>
                <span class="k">if</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">normal</span> <span class="o">=</span> <span class="o">-</span><span class="n">normal</span> <span class="c1"># Flip the normal vector</span>
                <span class="c1"># Normalize the normal vector to have a magnitude of 1</span>
                <span class="n">normal</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">normal</span></div>


<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.extend_point_away">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.extend_point_away">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">extend_point_away</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">site</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">center</span><span class="p">,</span><span class="n">height</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Offset a surface site along its normal vector direction.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - site : ndarray</span>
<span class="sd">                        The position of the site to be offset.</span>

<span class="sd">                - pos : list of ndarray</span>
<span class="sd">                        The positions of the initial atoms used to generate the site.</span>

<span class="sd">                - center : ndarray</span>
<span class="sd">                        The center point of the slab (used to determine the direction of offset).</span>

<span class="sd">                - height : float</span>
<span class="sd">                        The distance to offset the site along the normal vector.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - new_site : ndarray</span>
<span class="sd">                        The new position of the site after applying the offset.</span>

<span class="sd">                - normal_vector : ndarray</span>
<span class="sd">                        The normal vector used for the offset.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># Determine the direction of offset based on the site&#39;s position relative to the slab center</span>
                <span class="k">if</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Offset upwards if the site is above the slab center</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Offset downwards if the site is below the slab center</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># If there are exactly 3 points, calculate the normal vector directly</span>
                        <span class="n">normal_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_normal_vector</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Indices of all unique triangles formed by 4 points</span>
                        <span class="n">normal_vectors</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                               <span class="c1"># Calculate the normal vector for each triangle</span>
                               <span class="n">vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_normal_vector</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                               <span class="n">normal_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> 
                        <span class="c1"># Compute the mean normal vector (average direction)</span>
                        <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">normal_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">return</span>  <span class="n">site</span><span class="o">+</span><span class="n">normal_vector</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">sign</span> <span class="p">,</span> <span class="n">normal_vector</span><span class="o">*</span><span class="n">sign</span></div>


<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.surf_topo">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.surf_topo">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">surf_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># Identify surface atoms and their indices based on coordination number.</span>
                <span class="n">surface_index</span> <span class="p">,</span> <span class="n">surface_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_atoms</span><span class="p">(</span><span class="n">both_surface</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">both_surface</span><span class="p">)</span>
                <span class="c1"># Get positions of surface atoms depending on periodic boundary conditions (PBC).</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">surface_atoms</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_surface_cells</span><span class="p">(</span><span class="n">surface_atoms</span><span class="o">.</span><span class="n">get_positions</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

                <span class="c1"># Create an AlphaComplex from surface atom coordinates.</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="n">gudhi</span><span class="o">.</span><span class="n">AlphaComplex</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_simplex_tree</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># Build simplex tree with radius constraint.</span>

                <span class="c1"># Retrieve simplices (points, edges, triangles, etc.) from the AlphaComplex.   </span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                <span class="c1"># Compute the center of mass for the entire structure.</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
                <span class="c1"># Initialize variables to store surface sites and helper data structures.</span>
                <span class="n">sites</span><span class="o">=</span> <span class="p">[]</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Sort simplices by size.</span>
                <span class="n">del_bri_couple</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Store bridge sites to be deleted.</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">surface_atoms</span><span class="p">)</span> <span class="c1"># Number of surface atoms.</span>
                <span class="n">fold4_group</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Store  4-fold groups.</span>
                <span class="n">tri_groups</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Store triangle groups.</span>
                 <span class="c1"># Iterate through all simplices in the AlphaComplex.</span>
                <span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">combinations</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># Process simplices with more than two points.</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Get coordinates of the simplex vertices.</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Get covalent radii.</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">cov_radii</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># Calculate centroid of the simplex.</span>

                                <span class="c1"># Skip sites above a certain height threshold.</span>
                                <span class="k">if</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">:</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Determine bond length threshold for neighboring atoms.</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                <span class="c1"># Identify indices of neighboring atoms within the bond length.</span>
                                <span class="n">temp_com</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[]</span>
                                
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">site</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bond_len</span><span class="p">:</span>
                                                <span class="n">temp_com</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">surface_atoms</span><span class="p">)</span>
                                                <span class="n">cov_radii</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
                                <span class="c1"># Process 4-fold sites.</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                        <span class="n">site_type</span> <span class="o">=</span> <span class="s1">&#39;4fold&#39;</span>
                                        <span class="n">index_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">index_tuple</span> <span class="ow">in</span> <span class="n">fold4_group</span><span class="p">:</span>
                                                <span class="k">continue</span> <span class="c1"># Skip duplicate 4-fold groups.</span>
                                        <span class="k">else</span><span class="p">:</span>
                                                <span class="n">site</span> <span class="o">=</span> <span class="n">calculate_centroid</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">temp_com</span><span class="p">],</span><span class="n">cov_radii</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># Recalculate centroid.</span>
                                                <span class="n">fold4_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_tuple</span><span class="p">)</span> <span class="c1"># Add group to the processed list.</span>

                                                <span class="c1"># Determine bridge sites to delete for 4-fold groups.</span>
                                                <span class="n">max_d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">:</span>
                                                                <span class="n">max_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                                                                <span class="n">temp_i</span> <span class="o">=</span> <span class="n">ind</span>
                                                <span class="n">del_bri_couple</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">temp_i</span><span class="p">))</span>
                                                <span class="n">remain</span> <span class="o">=</span> <span class="p">[]</span>
                                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">:</span>
                                                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">temp_com</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">temp_i</span><span class="p">:</span>
                                                                <span class="n">remain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                                <span class="n">del_bri_couple</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remain</span><span class="p">))</span>  
                                <span class="c1"># Process triangular hollow sites.                    </span>
                                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                                        <span class="n">site_type</span> <span class="o">=</span> <span class="s1">&#39;hollow&#39;</span>
                                        <span class="n">tri_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_com</span><span class="p">)</span> <span class="c1"># Add to triangle groups.</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Skip sites outside the valid range.</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_in_range</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Determine the height offset for the site based on bond length.</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                <span class="k">try</span><span class="p">:</span>       
                                        <span class="n">height</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">**</span> <span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                                        <span class="n">height</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># Default height for numerical issues.</span>
                                <span class="c1"># Offset site along the surface normal vector.</span>
                                <span class="n">site</span> <span class="p">,</span> <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend_point_away</span><span class="p">(</span><span class="n">site</span><span class="p">,</span><span class="n">coords</span><span class="p">[</span><span class="n">temp_com</span><span class="p">],</span><span class="n">center</span><span class="p">,</span><span class="n">height</span><span class="p">)</span>

                                <span class="c1"># Check if the site is too close to any existing atom.</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span> <span class="o">&lt;</span> <span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span> 
                                <span class="c1"># Add valid sites to the list.</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="p">:</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                                <span class="s1">&#39;site&#39;</span><span class="p">:</span><span class="n">site_type</span><span class="p">,</span>
                                                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;normal&#39;</span><span class="p">:</span><span class="n">normal</span><span class="p">,</span>
                                                <span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="n">site</span><span class="p">,</span>
                                                <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp_com</span><span class="p">]</span>
                                        <span class="p">})</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">surface_index</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># Process bridge sites.</span>
                                
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">in</span> <span class="n">del_bri_couple</span><span class="p">:</span>
                                        <span class="k">continue</span> <span class="c1"># Skip bridge sites that overlap with 4-fold sites.</span>
                                <span class="n">lam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="c1"># Default scaling factor for bond length.</span>
                                <span class="k">for</span> <span class="n">couple</span> <span class="ow">in</span> <span class="n">tri_groups</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">couple</span> <span class="ow">and</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">couple</span><span class="p">:</span>
                                                <span class="n">lam</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># Adjust factor for triangles.</span>
                                                <span class="k">break</span>             
                                <span class="n">cov_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>   <span class="c1"># Get covalent radii.</span>
                                <span class="n">t</span> <span class="o">=</span> <span class="n">cov_radii</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span>  <span class="c1"># Weight factor for interpolation.</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Interpolated position for bridge site.</span>

                                <span class="c1"># Skip sites outside the valid range.</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_in_range</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                                        <span class="k">continue</span>
                                <span class="c1"># Find neighboring atoms for normal vector calculation.</span>
                                <span class="n">neigh_coords</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">site</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">*</span><span class="n">lam</span><span class="p">:</span>
                                                <span class="n">neigh_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh_coords</span><span class="p">)</span>

                                <span class="c1"># Calculate surface normal vector.</span>
                                <span class="n">normal</span> <span class="o">=</span> <span class="n">plane_normal</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
                                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                                        <span class="n">up</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">up</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">normal</span> <span class="o">*=</span> <span class="n">up</span>  
                                <span class="c1"># Determine height offset.</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cov_radii</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                <span class="k">try</span><span class="p">:</span>      
                                        <span class="n">height</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">**</span> <span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                                        <span class="n">height</span> <span class="o">=</span> <span class="mf">0.1</span>
                                <span class="c1"># Offset site along the normal vector.</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">site</span> <span class="o">+</span> <span class="n">normal</span><span class="o">*</span><span class="n">height</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="c1"># Check if the site is too close to any existing atom.</span>
                                <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span> <span class="o">&lt;</span> <span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span> 
                                <span class="c1"># Add valid sites to the list.</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="p">:</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                                <span class="s1">&#39;site&#39;</span><span class="p">:</span><span class="s1">&#39;bridge&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;normal&#39;</span><span class="p">:</span><span class="n">normal</span><span class="p">,</span>
                                                <span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="n">site</span><span class="p">,</span>
                                                <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                        <span class="p">})</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">surface_index</span><span class="p">[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span><span class="c1"># Process top sites.</span>
                                <span class="n">temp</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="c1"># Skip sites outside the valid range.</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_in_range</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                                        <span class="k">continue</span>
                                <span class="n">metal</span> <span class="o">=</span> <span class="n">surface_atoms</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span>
                                <span class="c1"># Find neighboring atoms for normal vector calculation.</span>
                                <span class="n">neigh_coords</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                                        <span class="n">neigh_len</span> <span class="o">=</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">+</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">surface_atoms</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">site</span> <span class="o">-</span> <span class="n">coord</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">neigh_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
                                                <span class="n">neigh_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neigh_coords</span><span class="p">)</span>
                                <span class="c1"># Calculate surface normal vector.</span>
                                <span class="n">normal</span> <span class="o">=</span> <span class="n">plane_normal</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
                                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                                        <span class="n">up</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">up</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="n">normal</span> <span class="o">*=</span> <span class="n">up</span>  
                                <span class="c1"># Determine height offset.</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metal</span><span class="p">,</span><span class="kc">None</span><span class="p">)]])</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span>
                                <span class="k">else</span><span class="p">:</span>
                                        <span class="n">bond_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_len</span>
                                <span class="n">height</span> <span class="o">=</span> <span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span>
                                <span class="c1"># Offset site along the normal vector.</span>
                                <span class="n">site</span> <span class="o">=</span> <span class="n">site</span><span class="o">+</span><span class="n">normal</span><span class="o">*</span><span class="n">height</span>
                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
                                 <span class="c1"># Check if the site is too close to any existing atom.</span>
                                <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">site</span><span class="p">)</span><span class="o">+</span><span class="mf">0.01</span> <span class="o">&lt;</span> <span class="n">bond_len</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span> 
                                <span class="c1"># Add valid sites to the list.</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="p">:</span>
                                        <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                                <span class="s1">&#39;site&#39;</span><span class="p">:</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;surface&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;normal&#39;</span><span class="p">:</span><span class="n">normal</span><span class="p">,</span>
                                                <span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="n">site</span><span class="p">,</span>
                                                <span class="s1">&#39;indices&#39;</span><span class="p">:[</span><span class="n">c</span><span class="o">%</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">com</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                        <span class="p">})</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">=</span> <span class="n">sites</span>
                <span class="c1"># Determine if the generating sites are too close together</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                                <span class="n">flag</span>  <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                                                <span class="k">break</span>
                                <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>  </div>


<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.get_inside_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.get_inside_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_inside_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">absorbent</span> <span class="o">=</span> <span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Retrieve sites inside the structure using topology analysis.</span>
<span class="sd">    </span>
<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list, optional</span>
<span class="sd">                        List of chemical elements to be considered when adjusting radii.</span>
<span class="sd">                </span>
<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - inside_site_list :  list</span>
<span class="sd">                        A list of identified inside sites.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">absorbent</span><span class="p">:</span> <span class="c1"># If an absorbent list is provided, adjust the radii based on the minimum covalent radius of the absorbent elements.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">inside_add_radii</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span><span class="kc">None</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">absorbent</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_topo</span><span class="p">()</span> <span class="c1"># Perform topological analysis to find inside sites.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span></div>

        
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.get_surface_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.get_surface_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_surface_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">absorbent</span> <span class="o">=</span> <span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Retrieve sites inside the structure using topology analysis.</span>
<span class="sd">    </span>
<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list, optional</span>
<span class="sd">                        List of chemical elements to be considered when adjusting radii.</span>
<span class="sd">                </span>
<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - surf_site_list : list</span>
<span class="sd">                        A list of identified surface sites.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># If an absorbent list is provided, adjust the radii based on the minimum covalent radius of the absorbent elements.</span>
                <span class="k">if</span> <span class="n">absorbent</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">surface_add_radii</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ele</span><span class="p">,</span><span class="kc">None</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">absorbent</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surf_topo</span><span class="p">()</span> <span class="c1"># Perform topological analysis to find surface sites</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span></div>

        
<div class="viewcode-block" id="SlabAdsorptionsSitesFinder.get_sites">
<a class="viewcode-back" href="../../chem_topo.html#chem_topo.adsorption_sites.SlabAdsorptionsSitesFinder.get_sites">[docs]</a>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">absorbent</span> <span class="o">=</span> <span class="p">[]):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Retrieve all sites (surface and inside) for the structure.</span>

<span class="sd">                Parameters:</span>
<span class="sd">                -----------</span>
<span class="sd">                - absorbent : list, optional</span>
<span class="sd">                        List of chemical elements to adjust radii for site generation.</span>

<span class="sd">                Returns:</span>
<span class="sd">                --------</span>
<span class="sd">                - sites : list</span>
<span class="sd">                        A list of all sites (surface and inside) identified.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># If the sites have already been generated, return the cached result</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span>
                <span class="c1"># If surface sites have not been generated, generate them using the given absorbent elements.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_sites</span><span class="p">(</span><span class="n">absorbent</span><span class="o">=</span><span class="n">absorbent</span><span class="p">)</span>
                <span class="c1"># If inside sites have not been generated, generate them using the given absorbent elements.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_inside_sites</span><span class="p">(</span><span class="n">absorbent</span><span class="o">=</span><span class="n">absorbent</span><span class="p">)</span>
                <span class="c1"># Combine surface sites and inside sites into the full sites list.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_site_list</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inside_site_list</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, zheng shisheng , zhang ximing ,liu hengshu , liang gehao.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
